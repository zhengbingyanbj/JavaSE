面向对象 
       封装
	       方法的封装 类的封装 
		   private 私有化 
	   继承 
	      
	   多态
   面向对象(继承的引入和概述)(掌握)
	A:继承概述
	    理解1:存在一个现有类,让新类与它产生关系,新类具备现有类的属性和方法,这个关系就是继承

		理解2:
		      多个类中存在相同属性和行为时，
		      将这些内容抽取到单独一个类中，
			  那么多个类无需再定义这些属性和行为，只要继承那个类即可。
	B:继承格式
		通过extends关键字可以实现类与类的继承
		class 子类名 extends 父类名 {}  
		单独的这个类称为父类，基类或者超类；
		这多个类可以称为子类或者派生类。
        有了继承以后,我们定义一个类的时候,可以在一个已经存在的类的基础上,还可以定义自己的新成员.

   面向对象(继承中成员变量的关系)(掌握)(要掌握查找的顺序)
	A:子类中的成员变量和父类中的成员变量名称不一样
	B:子类中的成员变量和父类中的成员变量名称一样
		在子类中访问一个变量的查找顺序("就近原则")
			a: 在子类的方法的局部范围找,有就使用
			b: 在子类的成员范围找,有就使用
			c: 在父类的成员范围找,有就使用
			d: 如果还找不到,就报错
   
	子类中的成员方法和父类中的方法名称不一样
	      首先去子类中看有没有该方法
		  没有 去父类中找 

   面向对象(Java中类的继承特点)(掌握)  
        
	A:Java中类的继承特点
		a:Java只支持单继承，不支持多继承。
			有些语言是支持多继承，格式：extends 类1,类2,...
		b:Java支持多层继承(继承体系)
	B:案例演示
		Java中类的继承特点
    
  面向对象(什么时候使用继承)
   
	什么时候使用继承
		继承其实体现的是一种关系："is a" .		
		采用假设法。
			如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。
			水果  香蕉 
			人   学生
			苹果  梨

  
  面向对象(继承案例演示以及继承的好处和弊端)(掌握) 记住好处重点要知道 继承是多态的前提
	A:需求：
		学生类和老师类。
		定义两个功能(吃饭，睡觉)
	B:案例演示
		使用继承前
	C:案例演示
		使用继承后
	D:继承的好处
		a:提高了代码的复用性
		b:提高了代码的维护性
		c:让类与类之间产生了关系，是多态的前提
	E:继承的弊端(了解)
		类的耦合性增强了。
		
		开发的原则：高内聚，低耦合。
		耦合：类与类的关系
		内聚：就是自己完成某件事情的能力

(方法重写概述及其应用)(掌握)
	A:什么是方法重写
		子类中出现了和父类中一模一样的方法声明(方法名,参数列表,返回值类型)，也被称为方法覆盖，方法复写。
	B:方法重写的应用：
		当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。
		这样，即沿袭了父类的功能，又定义了子类特有的内容。
	C:案例演示
		a:定义一个手机类。
		b:通过研究，我发明了一个新手机，这个手机的作用是在打完电话后，可以听天气预报。

(方法重写的注意事项)(掌握)(
记住这几个注意事项,写程序的时候记住不重写父类的私有,重写的时候权限保持一致,最好声明是一模一样包括(static))
	A:方法重写注意事项
		a:父类中私有方法不能被重写
			因为父类私有方法子类根本就无法访问到
		b:子类重写父类方法时，访问权限不能更低
			最好就一致
		子类重写父类方法的时候，最好声明一模一样。
	B:案例演示
		方法重写注意事项

(this和super的区别和应用)    (搞清楚this可以调用本类中的成员方法,成员变量,构造方法 )
                                                  (搞清楚super可以调用父类中的成员方法,成员变量,构造方法 )
	A:通过问题引出super
		子类局部范围访问父类成员变量
	B:说说this和super的区别
		this代表的是本类对象的引用
		super代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)
	C:this和super的使用
		a:调用成员变量
			this.成员变量 	调用本类的成员变量
			super.成员变量 	调用父类的成员变量
		b:调用构造方法
			this(...)			调用本类的构造方法
			super(...)			调用父类的构造方法
		c:调用成员方法
			this.成员方法() 	调用本类的成员方法
			super.成员方法() 	调用父类的成员方法
		
	
(继承中构造方法的关系 就是那张图)(掌握)(在子类做初始化的时候一定先对父类进行初始化,所以子类构造默认有super())
	A:案例演示
		子类中所有的构造方法默认都会访问父类中空参数的构造方法
	B:为什么呢?
		因为子类会继承父类中的数据，可能还会使用父类的数据。
		所以，子类初始化之前，一定要先完成父类数据的初始化。
		
		其实：(了解)
			每一个构造方法的第一条语句默认都是：super()
			Object类。否则有人就会针对父类的构造方法有疑问。Object在没有父类了。
	C:注意事项
		super(…)或者this(….)必须出现在第一条语句上
		如果是不放在第一句上,就可以出现对父类的数据进行多次初始化,所以必须放在第一句

(抽象类的概述及其特点)(掌握)

	A:抽象类概述
		回想前面我们的猫狗案例，提取出了一个动物类。并且我们在前面也创建过了动物对象，其实这是不对的。
    		为什么呢?因为，我说动物，你知道我说的是什么动物吗?只有看到了具体的动物，你才知道，这是什么动物。 
		所以说，动物本身并不是一个具体的事物，而是一个抽象的事物。只有真正的猫，狗才是具体的动物。
		同理，我们也可以推想，不同的动物吃的东西应该是不一样的，所以，我们不应该在动物类中给出具体体现，而是应该给出一个声明即可。
		在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。
	B:抽象类特点
		a:抽象类和抽象方法必须用abstract关键字修饰
			抽象类格式:		abstract class 类名 {}
			抽象方法格式:	public abstract 返回值类型 方法名();

			抽象方法是来声明方法的  
			重写后的方法  是来实现方法
		b:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类
		c:抽象类中有构造方法,抽象类不能进行实例化,那么要构造方法有什么作用呢?
			用于子类访问父类数据时的初始化
		d:抽象类不能实例化那么，抽象类如何实例化呢?
			按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。
		e:抽象类的子类
			要么是抽象类
			要么重写抽象类中的所有抽象方法的具体类
	C:案例演示
		抽象类特点

(抽象类的成员特点)(掌握)

	A:抽象类的成员特点
		a:成员变量：既可以是变量，也可以是常量。
		b:构造方法：有。
					用于子类访问父类数据的初始化。
		c:成员方法：既可以是抽象的，也可以是非抽象的。
	B:案例演示
		抽象类的成员特点
	C:抽象类的成员方法特性：
		a:抽象方法 		强制要求子类做的事情。
		b:非抽象方法 	子类继承的事情，提高代码复用性。

   完成 一个员工案例 


   程序猿   攻城狮 