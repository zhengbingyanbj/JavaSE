List:
	特性：1）有序集合、2）有索引、3）可以存储重复元素。
	特有的抽象方法：
		带有索引，就是List私有的方法
		add(int index,E e);	//将元素插入到指定的索引上，原有位置上的元素向后顺移。
		E  remove(int index);
				1）Collection的remove()参数是Object,List 的参数是索引值。
				2）根据索引去移除元素。返回值是被删除之前的元素。
		E set(int index,E e);
			1）修改指定索引上的元素；
			2）返回值是移除之前的元素	
			注意：set是在原有元素上修改，与add不同。
List有三种遍历方式： 
	迭代器，增强for，普通for
并发修改异常：
	迭代器工作过程中，修改了集合的元素。
	在遍历过程中，使用集合的方法修改了集合的长度，是不可以的。
集合存储结构：
	堆栈，先进后出。
	队列，先进先出。
	数组，查找快，通过索引直接查找，数组元素是有地址
		  增删慢：长度不可变，添加新元素导致重新创建数组。
	链表结构：节点与节点之间，数据地址记录的方式存储。
		  查找速度慢，地址不是连续的
		  增删快：不会破坏原有结构，更换地址记录即可
实现类：
	ArrayList集合（数组底层实现）：
		大小可变的数组，线程不安全（效率高）。
		默认大小是 10 ，也可以指定长度。
	LinkedList集合（链表底层实现）：
		增删快，查询慢。 线程不同步，效率高。
		可以单独操作开头，或者结尾。有许多首尾操作。
		addFrist(E); 添加到链表开头
		addLast(E);	添加到列表末尾。
		getFrist();获取链表的结尾
		getLast(); 获取链表的开头
		removeFrist(); 移除,并返回元素
		removeLast(); 
		isEmpty(); 集合等于空，返回true。
	Vector：
		可增长对象数组，有索引。与ArrayList作用一致。
		线程安全，被ArrayList取代。

Set接口：
	set接口的方法与Collection方法相同
	不允许存储重复元素，没有索引。
	无序集合；
	取出方式：迭代器，增强for 没有索引。
实现类：
	HashSet(set本质依赖于Map实例):	创建set时返回的是map
		底层数据结构：哈希表
		存储，取出都比较快
		线程不安全，效率高
	hashtable：哈希表，链表数组结合体，所以增删快，查询也快。
		哈希表中：数组长度默认16，加载因子为0.75 ，算法为数组长度 * 0.75（o.75就是百分比，当数组使用率达到75%时，就会对数组进行扩容，复制创建新的数组，数据的再hash.）
	对象的Hash值，普通的十进制。
	hashcode();方法返回的值，叫做hash值，每个对象都有一个hash值，hash值是存储到Hashset集合的依据。
	String 重写hashCode方法，String的源码：
Hashset的存储过程：
	首先判断hash值是否相同，没有直接存储，有就比较hash值。
	再使用equals方法，判断内容是否相同。
	两个方法的结果都是true时，才不会储存。
如果hash值相同，但是equals比较之后不同，就认为没有重复：
	但是这时候会，使用链表方式，将hash值相同，内容不同的两个对象，挂到桶中。 

TreeSet:，有序，不可重复。
	两种排序方式：	
		空参：使用空参就需要，去实现comportor
		传入Compartor接口： 直接使用匿名内部类方式
	自然排序：前 - 后是降序，后 - 前是升序。
		存入TreeSet集合的是包装类型时，包装类实现了Compartor接口。
			使用二叉树存储，先存入根节点，然后后添加的元素与根节点比较，相减，等于负数放左边，正数放右边
			每个节点向下生成两个子节点，取元素时按照：左-中-右顺序取出，从最左边开始取
		让集合类重写Compartor接口，方法内自己定义排序规则。
			 负数向左边存，0代表重复不添加，正数向右添加。
	实现Compartor接口：（自定义类，必须实现Comporttor接口。）
		创建TreeSet的时候，传入比较器接口，重写比较方法.
		排序的依据还是一样的：
			使用二叉树存储，先存入根节点，然后后添加的元素与根节点比较，相减，等于负数放左边，正数放右边
			每个节点向下生成两个子节点，取元素时按照：左-中-右顺序取出，从最左边开始取