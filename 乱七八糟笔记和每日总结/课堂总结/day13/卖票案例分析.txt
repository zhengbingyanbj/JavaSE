模拟卖票案例：
			产生问题的原因：
				负数：
					关键点： tickets=1的时候，三个线程对象都进入到if()语句中了。
					当tickets的值=1的时候，此时线程1先抢到资源，判断tickets>0成立，所以线程1进来，
					线程1还没来记得继续往下执行的时候，线程2抢到了资源，线程2判断tickets>0成立，所以线程2进来，
					同理，线程2还没来记得继续往下执行的时候，线程3抢到了资源，线程3判断tickets>0成立，所以线程3进来
					此时，三个线程对象都已经进入到了if语句的里边：
						假设线程1先打印： tickets = 1, 完事儿后会将 tickets的值改为 0
						线程2打印的时候： tickets = 0，完事儿后会将 tickets的值改为 -1
						线程3打印的时候： tickets = -1，完事儿后会将 tickets的值改为 -2

				重复值： 
					关键点：tickets--     //tickets = tickets - 1;
						tickets--做了三件事情：
							1、读取tickets的值。
							2、修改tickets的值。
							3、将修改后的值重新赋值给tickets。
						当还没来得及重新赋值的时候，如果别的线程对象抢到了资源，打印的就是重复值。

		
			解决方案：
				使用同步代码块。
					格式：
						synchronized(锁对象){   //这里的锁对象可以是：任意对象。		
							//可能出问题的代码
						}
					注意：必须使用同一把锁，不然可能出现锁不住的情况。
					JDK1.5的新特性： 互斥锁。
					
					Lock lock = new ReentrantLock();
					lock.lock();
						//可能出问题的代码
					lock.unlock();